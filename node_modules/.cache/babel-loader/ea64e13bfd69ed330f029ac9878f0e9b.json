{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _errors = require(\"@ledgerhq/errors\");\n\nconst Tag = 0x05;\n\nfunction asUInt16BE(value) {\n  const b = Buffer.alloc(2);\n  b.writeUInt16BE(value, 0);\n  return b;\n}\n\nconst initialAcc = {\n  data: Buffer.alloc(0),\n  dataLength: 0,\n  sequence: 0\n};\n/**\n *\n */\n\nconst createHIDframing = (channel, packetSize) => {\n  return {\n    makeBlocks(apdu) {\n      let data = Buffer.concat([asUInt16BE(apdu.length), apdu]);\n      const blockSize = packetSize - 5;\n      const nbBlocks = Math.ceil(data.length / blockSize);\n      data = Buffer.concat([data, // fill data with padding\n      Buffer.alloc(nbBlocks * blockSize - data.length + 1).fill(0)]);\n      const blocks = [];\n\n      for (let i = 0; i < nbBlocks; i++) {\n        const head = Buffer.alloc(5);\n        head.writeUInt16BE(channel, 0);\n        head.writeUInt8(Tag, 2);\n        head.writeUInt16BE(i, 3);\n        const chunk = data.slice(i * blockSize, (i + 1) * blockSize);\n        blocks.push(Buffer.concat([head, chunk]));\n      }\n\n      return blocks;\n    },\n\n    reduceResponse(acc, chunk) {\n      let {\n        data,\n        dataLength,\n        sequence\n      } = acc || initialAcc;\n\n      if (chunk.readUInt16BE(0) !== channel) {\n        throw new _errors.TransportError(\"Invalid channel\", \"InvalidChannel\");\n      }\n\n      if (chunk.readUInt8(2) !== Tag) {\n        throw new _errors.TransportError(\"Invalid tag\", \"InvalidTag\");\n      }\n\n      if (chunk.readUInt16BE(3) !== sequence) {\n        throw new _errors.TransportError(\"Invalid sequence\", \"InvalidSequence\");\n      }\n\n      if (!acc) {\n        dataLength = chunk.readUInt16BE(5);\n      }\n\n      sequence++;\n      const chunkData = chunk.slice(acc ? 5 : 7);\n      data = Buffer.concat([data, chunkData]);\n\n      if (data.length > dataLength) {\n        data = data.slice(0, dataLength);\n      }\n\n      return {\n        data,\n        dataLength,\n        sequence\n      };\n    },\n\n    getReducedResult(acc) {\n      if (acc && acc.dataLength === acc.data.length) {\n        return acc.data;\n      }\n    }\n\n  };\n};\n\nvar _default = createHIDframing;\nexports.default = _default;","map":{"version":3,"sources":["../src/hid-framing.js"],"names":["Tag","b","Buffer","initialAcc","data","dataLength","sequence","createHIDframing","makeBlocks","asUInt16BE","apdu","blockSize","packetSize","nbBlocks","Math","blocks","i","head","chunk","reduceResponse","acc","TransportError","chunkData","getReducedResult"],"mappings":"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","sourcesContent":["// @flow\n\nimport { TransportError } from \"@ledgerhq/errors\";\n\nexport type ResponseAcc = ?{\n  data: Buffer,\n  dataLength: number,\n  sequence: number,\n};\n\nconst Tag = 0x05;\n\nfunction asUInt16BE(value) {\n  const b = Buffer.alloc(2);\n  b.writeUInt16BE(value, 0);\n  return b;\n}\n\nconst initialAcc = {\n  data: Buffer.alloc(0),\n  dataLength: 0,\n  sequence: 0,\n};\n\n/**\n *\n */\nconst createHIDframing = (channel: number, packetSize: number) => {\n  return {\n    makeBlocks(apdu: Buffer): Buffer[] {\n      let data = Buffer.concat([asUInt16BE(apdu.length), apdu]);\n      const blockSize = packetSize - 5;\n      const nbBlocks = Math.ceil(data.length / blockSize);\n      data = Buffer.concat([\n        data, // fill data with padding\n        Buffer.alloc(nbBlocks * blockSize - data.length + 1).fill(0),\n      ]);\n\n      const blocks = [];\n      for (let i = 0; i < nbBlocks; i++) {\n        const head = Buffer.alloc(5);\n        head.writeUInt16BE(channel, 0);\n        head.writeUInt8(Tag, 2);\n        head.writeUInt16BE(i, 3);\n        const chunk = data.slice(i * blockSize, (i + 1) * blockSize);\n        blocks.push(Buffer.concat([head, chunk]));\n      }\n      return blocks;\n    },\n\n    reduceResponse(acc: ResponseAcc, chunk: Buffer): ResponseAcc {\n      let { data, dataLength, sequence } = acc || initialAcc;\n\n      if (chunk.readUInt16BE(0) !== channel) {\n        throw new TransportError(\"Invalid channel\", \"InvalidChannel\");\n      }\n      if (chunk.readUInt8(2) !== Tag) {\n        throw new TransportError(\"Invalid tag\", \"InvalidTag\");\n      }\n      if (chunk.readUInt16BE(3) !== sequence) {\n        throw new TransportError(\"Invalid sequence\", \"InvalidSequence\");\n      }\n\n      if (!acc) {\n        dataLength = chunk.readUInt16BE(5);\n      }\n      sequence++;\n      const chunkData = chunk.slice(acc ? 5 : 7);\n      data = Buffer.concat([data, chunkData]);\n      if (data.length > dataLength) {\n        data = data.slice(0, dataLength);\n      }\n\n      return {\n        data,\n        dataLength,\n        sequence,\n      };\n    },\n\n    getReducedResult(acc: ResponseAcc): ?Buffer {\n      if (acc && acc.dataLength === acc.data.length) {\n        return acc.data;\n      }\n    },\n  };\n};\n\nexport default createHIDframing;\n"]},"metadata":{},"sourceType":"script"}