{"ast":null,"code":"// type Var = {\n//   name: String\n//   type: \"uint256\" | \"bytes32\" | ...\n// }\n//\n// type Method = {\n//   name: String\n//   inputs: [Var]\n//   output: [Var]\n//   constant: Bool\n//   payable: Bool\n// }\nconst Bytes = require(\"./bytes\");\n\nconst Nat = require(\"./nat\");\n\nconst keccak256s = require(\"./hash\").keccak256s; // (type : String), JSType(type) -> {data: Bytes, dynamic: Bool}\n//   ABI-encodes a single term.\n\n\nconst encode = (type, value) => {\n  if (type === \"bytes\") {\n    const length = Bytes.length(value);\n    const nextMul32 = (((length - 1) / 32 | 0) + 1) * 32;\n    const lengthEncoded = encode(\"uint256\", Nat.fromNumber(length)).data;\n    const bytesEncoded = Bytes.padRight(nextMul32, value);\n    return {\n      data: Bytes.concat(lengthEncoded, bytesEncoded),\n      dynamic: true\n    };\n  } else if (type === \"uint256\" || type === \"bytes32\" || type === \"address\") {\n    return {\n      data: Bytes.pad(32, value),\n      dynamic: false\n    };\n  } else {\n    throw \"Eth-lib can't encode ABI type \" + type + \" yet.\";\n  }\n}; // (method : Method), [JSType(method.inputs[i].type)] -> Bytes\n//   ABI-encodes the transaction data to call a method.\n\n\nconst methodData = (method, params) => {\n  const methodSig = method.name + \"(\" + method.inputs.map(i => i.type).join(\",\") + \")\";\n  const methodHash = keccak256s(methodSig).slice(0, 10);\n  let encodedParams = params.map((param, i) => encode(method.inputs[i].type, param));\n  var headBlock = \"0x\";\n  let dataBlock = \"0x\";\n\n  for (var i = 0; i < encodedParams.length; ++i) {\n    if (encodedParams[i].dynamic) {\n      var dataLoc = encodedParams.length * 32 + Bytes.length(dataBlock);\n      headBlock = Bytes.concat(headBlock, Bytes.pad(32, Nat.fromNumber(dataLoc)));\n      dataBlock = Bytes.concat(dataBlock, encodedParams[i].data);\n    } else {\n      headBlock = Bytes.concat(headBlock, encodedParams[i].data);\n    }\n  }\n\n  return Bytes.flatten([methodHash, headBlock, dataBlock]);\n};\n\nmodule.exports = {\n  encode,\n  methodData\n};","map":{"version":3,"names":["Bytes","require","Nat","keccak256s","encode","type","value","length","nextMul32","lengthEncoded","fromNumber","data","bytesEncoded","padRight","concat","dynamic","pad","methodData","method","params","methodSig","name","inputs","map","i","join","methodHash","slice","encodedParams","param","headBlock","dataBlock","dataLoc","flatten","module","exports"],"sources":["/home/chizaaa/Documents/code-jam/celo-hodler/code-jam/node_modules/eth-lib/lib/abi.js"],"sourcesContent":["// type Var = {\n//   name: String\n//   type: \"uint256\" | \"bytes32\" | ...\n// }\n//\n// type Method = {\n//   name: String\n//   inputs: [Var]\n//   output: [Var]\n//   constant: Bool\n//   payable: Bool\n// }\n\nconst Bytes = require(\"./bytes\");\nconst Nat = require(\"./nat\");\nconst keccak256s = require(\"./hash\").keccak256s;\n\n// (type : String), JSType(type) -> {data: Bytes, dynamic: Bool}\n//   ABI-encodes a single term.\nconst encode = (type, value) => {\n  if (type === \"bytes\") {\n    const length = Bytes.length(value);\n    const nextMul32 = (((length - 1) / 32 | 0) + 1) * 32;\n    const lengthEncoded = encode(\"uint256\", Nat.fromNumber(length)).data;\n    const bytesEncoded = Bytes.padRight(nextMul32, value);\n    return { data: Bytes.concat(lengthEncoded, bytesEncoded), dynamic: true };\n  } else if (type === \"uint256\" || type === \"bytes32\" || type === \"address\") {\n    return { data: Bytes.pad(32, value), dynamic: false };\n  } else {\n    throw \"Eth-lib can't encode ABI type \" + type + \" yet.\";\n  }\n};\n\n// (method : Method), [JSType(method.inputs[i].type)] -> Bytes\n//   ABI-encodes the transaction data to call a method.\nconst methodData = (method, params) => {\n  const methodSig = method.name + \"(\" + method.inputs.map(i => i.type).join(\",\") + \")\";\n  const methodHash = keccak256s(methodSig).slice(0, 10);\n  let encodedParams = params.map((param, i) => encode(method.inputs[i].type, param));\n  var headBlock = \"0x\";\n  let dataBlock = \"0x\";\n  for (var i = 0; i < encodedParams.length; ++i) {\n    if (encodedParams[i].dynamic) {\n      var dataLoc = encodedParams.length * 32 + Bytes.length(dataBlock);\n      headBlock = Bytes.concat(headBlock, Bytes.pad(32, Nat.fromNumber(dataLoc)));\n      dataBlock = Bytes.concat(dataBlock, encodedParams[i].data);\n    } else {\n      headBlock = Bytes.concat(headBlock, encodedParams[i].data);\n    }\n  }\n  return Bytes.flatten([methodHash, headBlock, dataBlock]);\n};\n\nmodule.exports = {\n  encode,\n  methodData\n};"],"mappings":"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"},"metadata":{},"sourceType":"script"}