{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Lock = void 0;\n\nvar events_1 = require(\"events\");\n\nvar LockEvent;\n\n(function (LockEvent) {\n  LockEvent[\"Unlock\"] = \"unlock\";\n})(LockEvent || (LockEvent = {})); // Lock which can be used to ensure mutual exclusion in concurrent code.\n//\n// This lock is non-reentrant, and attempting to acquire it while holding the lock will result in a deadlock.\n\n\nvar Lock =\n/** @class */\nfunction () {\n  function Lock() {\n    this.locked = false;\n    this.emitter = new events_1.EventEmitter();\n  } // Attempt to acquire the lock without blocking.\n  // @returns {boolean} True if the lock was acquired.\n\n\n  Lock.prototype.tryAcquire = function () {\n    if (!this.locked) {\n      this.locked = true;\n      return true;\n    }\n\n    return false;\n  }; // Acquire the lock, blocking until the lock is available.\n\n\n  Lock.prototype.acquire = function () {\n    var _this = this;\n\n    return new Promise(function (resolve, reject) {\n      // Attempt to grab the lock without waiting.\n      if (_this.tryAcquire()) {\n        resolve();\n        return;\n      } // Wait for an event emitted when releasing the lock.\n\n\n      var callback = function () {\n        try {\n          if (_this.tryAcquire()) {\n            _this.emitter.removeListener(LockEvent.Unlock, callback);\n\n            resolve();\n          }\n        } catch (error) {\n          reject(error);\n        }\n      };\n\n      _this.emitter.on(LockEvent.Unlock, callback);\n    });\n  }; // Release the lock such that another caller can acquire it.\n  // If not locked, calling this method has no effect.\n\n\n  Lock.prototype.release = function () {\n    if (this.locked) {\n      this.locked = false;\n      this.emitter.emit(LockEvent.Unlock);\n    }\n  };\n\n  return Lock;\n}();\n\nexports.Lock = Lock;","map":{"version":3,"sources":["../src/lock.ts"],"names":[],"mappings":";;;;;;;AAAA,IAAA,QAAA,GAAA,OAAA,CAAA,QAAA,CAAA;;AAEA,IAAK,SAAL;;AAAA,CAAA,UAAK,SAAL,EAAc;EACZ,SAAA,CAAA,QAAA,CAAA,GAAA,QAAA;AACD,CAFD,EAAK,SAAS,KAAT,SAAS,GAAA,EAAA,CAAd,E,CAIA;AACA;AACA;;;AACA,IAAA,IAAA;AAAA;AAAA,YAAA;EAIE,SAAA,IAAA,GAAA;IAHQ,KAAA,MAAA,GAAkB,KAAlB;IAIN,KAAK,OAAL,GAAe,IAAI,QAAA,CAAA,YAAJ,EAAf;EACD,CANH,CAQE;EACA;;;EACA,IAAA,CAAA,SAAA,CAAA,UAAA,GAAA,YAAA;IACE,IAAI,CAAC,KAAK,MAAV,EAAkB;MAChB,KAAK,MAAL,GAAc,IAAd;MACA,OAAO,IAAP;IACD;;IACD,OAAO,KAAP;EACD,CAND,CAVF,CAkBE;;;EACA,IAAA,CAAA,SAAA,CAAA,OAAA,GAAA,YAAA;IAAA,IAAA,KAAA,GAAA,IAAA;;IACE,OAAO,IAAI,OAAJ,CAAY,UAAC,OAAD,EAAU,MAAV,EAAgB;MACjC;MACA,IAAI,KAAI,CAAC,UAAL,EAAJ,EAAuB;QACrB,OAAO;QACP;MACD,CALgC,CAOjC;;;MACA,IAAM,QAAQ,GAAG,YAAA;QACf,IAAI;UACF,IAAI,KAAI,CAAC,UAAL,EAAJ,EAAuB;YACrB,KAAI,CAAC,OAAL,CAAa,cAAb,CAA4B,SAAS,CAAC,MAAtC,EAA8C,QAA9C;;YACA,OAAO;UACR;QACF,CALD,CAKE,OAAO,KAAP,EAAc;UACd,MAAM,CAAC,KAAD,CAAN;QACD;MACF,CATD;;MAUA,KAAI,CAAC,OAAL,CAAa,EAAb,CAAgB,SAAS,CAAC,MAA1B,EAAkC,QAAlC;IACD,CAnBM,CAAP;EAoBD,CArBD,CAnBF,CA0CE;EACA;;;EACA,IAAA,CAAA,SAAA,CAAA,OAAA,GAAA,YAAA;IACE,IAAI,KAAK,MAAT,EAAiB;MACf,KAAK,MAAL,GAAc,KAAd;MACA,KAAK,OAAL,CAAa,IAAb,CAAkB,SAAS,CAAC,MAA5B;IACD;EACF,CALD;;EAMF,OAAA,IAAA;AAAC,CAlDD,EAAA;;AAAa,OAAA,CAAA,IAAA,GAAA,IAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Lock = void 0;\nvar events_1 = require(\"events\");\nvar LockEvent;\n(function (LockEvent) {\n    LockEvent[\"Unlock\"] = \"unlock\";\n})(LockEvent || (LockEvent = {}));\n// Lock which can be used to ensure mutual exclusion in concurrent code.\n//\n// This lock is non-reentrant, and attempting to acquire it while holding the lock will result in a deadlock.\nvar Lock = /** @class */ (function () {\n    function Lock() {\n        this.locked = false;\n        this.emitter = new events_1.EventEmitter();\n    }\n    // Attempt to acquire the lock without blocking.\n    // @returns {boolean} True if the lock was acquired.\n    Lock.prototype.tryAcquire = function () {\n        if (!this.locked) {\n            this.locked = true;\n            return true;\n        }\n        return false;\n    };\n    // Acquire the lock, blocking until the lock is available.\n    Lock.prototype.acquire = function () {\n        var _this = this;\n        return new Promise(function (resolve, reject) {\n            // Attempt to grab the lock without waiting.\n            if (_this.tryAcquire()) {\n                resolve();\n                return;\n            }\n            // Wait for an event emitted when releasing the lock.\n            var callback = function () {\n                try {\n                    if (_this.tryAcquire()) {\n                        _this.emitter.removeListener(LockEvent.Unlock, callback);\n                        resolve();\n                    }\n                }\n                catch (error) {\n                    reject(error);\n                }\n            };\n            _this.emitter.on(LockEvent.Unlock, callback);\n        });\n    };\n    // Release the lock such that another caller can acquire it.\n    // If not locked, calling this method has no effect.\n    Lock.prototype.release = function () {\n        if (this.locked) {\n            this.locked = false;\n            this.emitter.emit(LockEvent.Unlock);\n        }\n    };\n    return Lock;\n}());\nexports.Lock = Lock;\n//# sourceMappingURL=lock.js.map"]},"metadata":{},"sourceType":"script"}