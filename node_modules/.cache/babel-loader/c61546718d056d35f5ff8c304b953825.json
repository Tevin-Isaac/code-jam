{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.AttestationBase = exports.isAccountConsideredVerified = exports.extractAttestationCodeFromMessage = exports.messageContainsAttestationCode = exports.sanitizeMessageBase64 = exports.base64ToHex = exports.hashIdentifier = exports.getIdentifierPrefix = exports.IdentifierType = void 0;\n\nvar phoneNumbers_1 = require(\"./phoneNumbers\");\n\nvar DEFAULT_NUM_ATTESTATIONS_REQUIRED = 3;\nvar DEFAULT_ATTESTATION_THRESHOLD = 0.25; // Supported identifer types for attestations\n\nvar IdentifierType;\n\n(function (IdentifierType) {\n  IdentifierType[IdentifierType[\"PHONE_NUMBER\"] = 0] = \"PHONE_NUMBER\"; // In the future, other types like usernames or emails could go here\n})(IdentifierType = exports.IdentifierType || (exports.IdentifierType = {})); // Each identifer type has a unique prefix to prevent unlikely but possible collisions\n\n\nfunction getIdentifierPrefix(type) {\n  switch (type) {\n    case IdentifierType.PHONE_NUMBER:\n      return 'tel://';\n\n    default:\n      throw new Error('Unsupported Identifier Type');\n  }\n}\n\nexports.getIdentifierPrefix = getIdentifierPrefix;\n\nfunction hashIdentifier(sha3, identifier, type, salt) {\n  switch (type) {\n    case IdentifierType.PHONE_NUMBER:\n      return (0, phoneNumbers_1.getPhoneHash)(sha3, identifier, salt);\n\n    default:\n      throw new Error('Unsupported Identifier Type');\n  }\n}\n\nexports.hashIdentifier = hashIdentifier;\n\nfunction base64ToHex(base64String) {\n  return '0x' + Buffer.from(base64String, 'base64').toString('hex');\n}\n\nexports.base64ToHex = base64ToHex;\n\nfunction sanitizeMessageBase64(base64String) {\n  // Replace occurrences of ¿ with _. Unsure why that is happening right now\n  return base64String.replace(/(¿|§)/gi, '_');\n}\n\nexports.sanitizeMessageBase64 = sanitizeMessageBase64;\nvar attestationCodeRegex = new RegExp(/(.* |^)(?:celo:\\/\\/wallet\\/v\\/)?([a-zA-Z0-9=\\+\\/_-]{87,88})($| .*)/);\n\nfunction messageContainsAttestationCode(message) {\n  return attestationCodeRegex.test(message);\n}\n\nexports.messageContainsAttestationCode = messageContainsAttestationCode;\n\nfunction extractAttestationCodeFromMessage(message) {\n  var sanitizedMessage = sanitizeMessageBase64(message);\n\n  if (!messageContainsAttestationCode(sanitizedMessage)) {\n    return null;\n  }\n\n  var matches = sanitizedMessage.match(attestationCodeRegex);\n\n  if (!matches || matches.length < 3) {\n    return null;\n  }\n\n  return base64ToHex(matches[2]);\n}\n\nexports.extractAttestationCodeFromMessage = extractAttestationCodeFromMessage;\n/**\n * Returns true if an AttestationStat is considered verified using the given factors,\n * or defaults if factors are ommited.\n * @param stats AttestationStat of the account's attestation identitifer, retrievable via lookupIdentitfiers\n * @param numAttestationsRequired Optional number of attestations required.  Will default to\n *  hardcoded value if absent.\n * @param attestationThreshold Optional threshold for fraction attestations completed. Will\n *  default to hardcoded value if absent.\n */\n\nfunction isAccountConsideredVerified(stats, numAttestationsRequired, attestationThreshold) {\n  if (numAttestationsRequired === void 0) {\n    numAttestationsRequired = DEFAULT_NUM_ATTESTATIONS_REQUIRED;\n  }\n\n  if (attestationThreshold === void 0) {\n    attestationThreshold = DEFAULT_ATTESTATION_THRESHOLD;\n  }\n\n  if (!stats) {\n    return {\n      isVerified: false,\n      numAttestationsRemaining: 0,\n      total: 0,\n      completed: 0\n    };\n  }\n\n  var numAttestationsRemaining = numAttestationsRequired - stats.completed;\n  var fractionAttestation = stats.total < 1 ? 0 : stats.completed / stats.total; // 'verified' is a term of convenience to mean that the attestation stats for a\n  // given identifier are beyond a certain threshold of confidence\n\n  var isVerified = numAttestationsRemaining <= 0 && fractionAttestation >= attestationThreshold;\n  return {\n    isVerified: isVerified,\n    numAttestationsRemaining: numAttestationsRemaining,\n    total: stats.total,\n    completed: stats.completed\n  };\n}\n\nexports.isAccountConsideredVerified = isAccountConsideredVerified;\nexports.AttestationBase = {\n  IdentifierType: IdentifierType,\n  getIdentifierPrefix: getIdentifierPrefix,\n  hashIdentifier: hashIdentifier,\n  base64ToHex: base64ToHex,\n  sanitizeMessageBase64: sanitizeMessageBase64,\n  messageContainsAttestationCode: messageContainsAttestationCode,\n  extractAttestationCodeFromMessage: extractAttestationCodeFromMessage,\n  isAccountConsideredVerified: isAccountConsideredVerified\n};","map":{"version":3,"sources":["../src/attestations.ts"],"names":[],"mappings":";;;;;;;AAAA,IAAA,cAAA,GAAA,OAAA,CAAA,gBAAA,CAAA;;AAEA,IAAM,iCAAiC,GAAG,CAA1C;AACA,IAAM,6BAA6B,GAAG,IAAtC,C,CAEA;;AACA,IAAY,cAAZ;;AAAA,CAAA,UAAY,cAAZ,EAA0B;EACxB,cAAA,CAAA,cAAA,CAAA,cAAA,CAAA,GAAA,CAAA,CAAA,GAAA,cAAA,CADwB,CAExB;AACD,CAHD,EAAY,cAAc,GAAd,OAAA,CAAA,cAAA,KAAA,OAAA,CAAA,cAAA,GAAc,EAAd,CAAZ,E,CAKA;;;AACA,SAAgB,mBAAhB,CAAoC,IAApC,EAAwD;EACtD,QAAQ,IAAR;IACE,KAAK,cAAc,CAAC,YAApB;MACE,OAAO,QAAP;;IACF;MACE,MAAM,IAAI,KAAJ,CAAU,6BAAV,CAAN;EAJJ;AAMD;;AAPD,OAAA,CAAA,mBAAA,GAAA,mBAAA;;AASA,SAAgB,cAAhB,CACE,IADF,EAEE,UAFF,EAGE,IAHF,EAIE,IAJF,EAIe;EAEb,QAAQ,IAAR;IACE,KAAK,cAAc,CAAC,YAApB;MACE,OAAO,CAAA,GAAA,cAAA,CAAA,YAAA,EAAa,IAAb,EAAmB,UAAnB,EAA+B,IAA/B,CAAP;;IACF;MACE,MAAM,IAAI,KAAJ,CAAU,6BAAV,CAAN;EAJJ;AAMD;;AAZD,OAAA,CAAA,cAAA,GAAA,cAAA;;AAcA,SAAgB,WAAhB,CAA4B,YAA5B,EAAgD;EAC9C,OAAO,OAAO,MAAM,CAAC,IAAP,CAAY,YAAZ,EAA0B,QAA1B,EAAoC,QAApC,CAA6C,KAA7C,CAAd;AACD;;AAFD,OAAA,CAAA,WAAA,GAAA,WAAA;;AAIA,SAAgB,qBAAhB,CAAsC,YAAtC,EAA0D;EACxD;EACA,OAAO,YAAY,CAAC,OAAb,CAAqB,SAArB,EAAgC,GAAhC,CAAP;AACD;;AAHD,OAAA,CAAA,qBAAA,GAAA,qBAAA;AAKA,IAAM,oBAAoB,GAAG,IAAI,MAAJ,CAC3B,oEAD2B,CAA7B;;AAIA,SAAgB,8BAAhB,CAA+C,OAA/C,EAA8D;EAC5D,OAAO,oBAAoB,CAAC,IAArB,CAA0B,OAA1B,CAAP;AACD;;AAFD,OAAA,CAAA,8BAAA,GAAA,8BAAA;;AAIA,SAAgB,iCAAhB,CAAkD,OAAlD,EAAiE;EAC/D,IAAM,gBAAgB,GAAG,qBAAqB,CAAC,OAAD,CAA9C;;EAEA,IAAI,CAAC,8BAA8B,CAAC,gBAAD,CAAnC,EAAuD;IACrD,OAAO,IAAP;EACD;;EAED,IAAM,OAAO,GAAG,gBAAgB,CAAC,KAAjB,CAAuB,oBAAvB,CAAhB;;EACA,IAAI,CAAC,OAAD,IAAY,OAAO,CAAC,MAAR,GAAiB,CAAjC,EAAoC;IAClC,OAAO,IAAP;EACD;;EACD,OAAO,WAAW,CAAC,OAAO,CAAC,CAAD,CAAR,CAAlB;AACD;;AAZD,OAAA,CAAA,iCAAA,GAAA,iCAAA;AA0BA;;;;;;;;AAQG;;AACH,SAAgB,2BAAhB,CACE,KADF,EAEE,uBAFF,EAGE,oBAHF,EAG8D;EAD5D,IAAA,uBAAA,KAAA,KAAA,CAAA,EAAA;IAAA,uBAAA,GAAA,iCAAA;EAAmE;;EACnE,IAAA,oBAAA,KAAA,KAAA,CAAA,EAAA;IAAA,oBAAA,GAAA,6BAAA;EAA4D;;EAE5D,IAAI,CAAC,KAAL,EAAY;IACV,OAAO;MACL,UAAU,EAAE,KADP;MAEL,wBAAwB,EAAE,CAFrB;MAGL,KAAK,EAAE,CAHF;MAIL,SAAS,EAAE;IAJN,CAAP;EAMD;;EACD,IAAM,wBAAwB,GAAG,uBAAuB,GAAG,KAAK,CAAC,SAAjE;EACA,IAAM,mBAAmB,GAAG,KAAK,CAAC,KAAN,GAAc,CAAd,GAAkB,CAAlB,GAAsB,KAAK,CAAC,SAAN,GAAkB,KAAK,CAAC,KAA1E,CAX4D,CAY5D;EACA;;EACA,IAAM,UAAU,GAAG,wBAAwB,IAAI,CAA5B,IAAiC,mBAAmB,IAAI,oBAA3E;EAEA,OAAO;IACL,UAAU,EAAA,UADL;IAEL,wBAAwB,EAAA,wBAFnB;IAGL,KAAK,EAAE,KAAK,CAAC,KAHR;IAIL,SAAS,EAAE,KAAK,CAAC;EAJZ,CAAP;AAMD;;AAzBD,OAAA,CAAA,2BAAA,GAAA,2BAAA;AA2Ba,OAAA,CAAA,eAAA,GAAkB;EAC7B,cAAc,EAAA,cADe;EAE7B,mBAAmB,EAAA,mBAFU;EAG7B,cAAc,EAAA,cAHe;EAI7B,WAAW,EAAA,WAJkB;EAK7B,qBAAqB,EAAA,qBALQ;EAM7B,8BAA8B,EAAA,8BAND;EAO7B,iCAAiC,EAAA,iCAPJ;EAQ7B,2BAA2B,EAAA;AARE,CAAlB","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.AttestationBase = exports.isAccountConsideredVerified = exports.extractAttestationCodeFromMessage = exports.messageContainsAttestationCode = exports.sanitizeMessageBase64 = exports.base64ToHex = exports.hashIdentifier = exports.getIdentifierPrefix = exports.IdentifierType = void 0;\nvar phoneNumbers_1 = require(\"./phoneNumbers\");\nvar DEFAULT_NUM_ATTESTATIONS_REQUIRED = 3;\nvar DEFAULT_ATTESTATION_THRESHOLD = 0.25;\n// Supported identifer types for attestations\nvar IdentifierType;\n(function (IdentifierType) {\n    IdentifierType[IdentifierType[\"PHONE_NUMBER\"] = 0] = \"PHONE_NUMBER\";\n    // In the future, other types like usernames or emails could go here\n})(IdentifierType = exports.IdentifierType || (exports.IdentifierType = {}));\n// Each identifer type has a unique prefix to prevent unlikely but possible collisions\nfunction getIdentifierPrefix(type) {\n    switch (type) {\n        case IdentifierType.PHONE_NUMBER:\n            return 'tel://';\n        default:\n            throw new Error('Unsupported Identifier Type');\n    }\n}\nexports.getIdentifierPrefix = getIdentifierPrefix;\nfunction hashIdentifier(sha3, identifier, type, salt) {\n    switch (type) {\n        case IdentifierType.PHONE_NUMBER:\n            return (0, phoneNumbers_1.getPhoneHash)(sha3, identifier, salt);\n        default:\n            throw new Error('Unsupported Identifier Type');\n    }\n}\nexports.hashIdentifier = hashIdentifier;\nfunction base64ToHex(base64String) {\n    return '0x' + Buffer.from(base64String, 'base64').toString('hex');\n}\nexports.base64ToHex = base64ToHex;\nfunction sanitizeMessageBase64(base64String) {\n    // Replace occurrences of ¿ with _. Unsure why that is happening right now\n    return base64String.replace(/(¿|§)/gi, '_');\n}\nexports.sanitizeMessageBase64 = sanitizeMessageBase64;\nvar attestationCodeRegex = new RegExp(/(.* |^)(?:celo:\\/\\/wallet\\/v\\/)?([a-zA-Z0-9=\\+\\/_-]{87,88})($| .*)/);\nfunction messageContainsAttestationCode(message) {\n    return attestationCodeRegex.test(message);\n}\nexports.messageContainsAttestationCode = messageContainsAttestationCode;\nfunction extractAttestationCodeFromMessage(message) {\n    var sanitizedMessage = sanitizeMessageBase64(message);\n    if (!messageContainsAttestationCode(sanitizedMessage)) {\n        return null;\n    }\n    var matches = sanitizedMessage.match(attestationCodeRegex);\n    if (!matches || matches.length < 3) {\n        return null;\n    }\n    return base64ToHex(matches[2]);\n}\nexports.extractAttestationCodeFromMessage = extractAttestationCodeFromMessage;\n/**\n * Returns true if an AttestationStat is considered verified using the given factors,\n * or defaults if factors are ommited.\n * @param stats AttestationStat of the account's attestation identitifer, retrievable via lookupIdentitfiers\n * @param numAttestationsRequired Optional number of attestations required.  Will default to\n *  hardcoded value if absent.\n * @param attestationThreshold Optional threshold for fraction attestations completed. Will\n *  default to hardcoded value if absent.\n */\nfunction isAccountConsideredVerified(stats, numAttestationsRequired, attestationThreshold) {\n    if (numAttestationsRequired === void 0) { numAttestationsRequired = DEFAULT_NUM_ATTESTATIONS_REQUIRED; }\n    if (attestationThreshold === void 0) { attestationThreshold = DEFAULT_ATTESTATION_THRESHOLD; }\n    if (!stats) {\n        return {\n            isVerified: false,\n            numAttestationsRemaining: 0,\n            total: 0,\n            completed: 0,\n        };\n    }\n    var numAttestationsRemaining = numAttestationsRequired - stats.completed;\n    var fractionAttestation = stats.total < 1 ? 0 : stats.completed / stats.total;\n    // 'verified' is a term of convenience to mean that the attestation stats for a\n    // given identifier are beyond a certain threshold of confidence\n    var isVerified = numAttestationsRemaining <= 0 && fractionAttestation >= attestationThreshold;\n    return {\n        isVerified: isVerified,\n        numAttestationsRemaining: numAttestationsRemaining,\n        total: stats.total,\n        completed: stats.completed,\n    };\n}\nexports.isAccountConsideredVerified = isAccountConsideredVerified;\nexports.AttestationBase = {\n    IdentifierType: IdentifierType,\n    getIdentifierPrefix: getIdentifierPrefix,\n    hashIdentifier: hashIdentifier,\n    base64ToHex: base64ToHex,\n    sanitizeMessageBase64: sanitizeMessageBase64,\n    messageContainsAttestationCode: messageContainsAttestationCode,\n    extractAttestationCodeFromMessage: extractAttestationCodeFromMessage,\n    isAccountConsideredVerified: isAccountConsideredVerified,\n};\n//# sourceMappingURL=attestations.js.map"]},"metadata":{},"sourceType":"script"}