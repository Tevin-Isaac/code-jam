{"ast":null,"code":"import Transport from \"@ledgerhq/hw-transport\";\nimport hidFraming from \"@ledgerhq/devices/lib/hid-framing\";\nimport { identifyUSBProductId } from \"@ledgerhq/devices\";\nimport { log } from \"@ledgerhq/logs\";\nimport { TransportOpenUserCancelled, TransportInterfaceNotAvailable, TransportWebUSBGestureRequired, DisconnectedDeviceDuringOperation, DisconnectedDevice } from \"@ledgerhq/errors\";\nimport { getLedgerDevices, getFirstLedgerDevice, requestLedgerDevice, isSupported } from \"./webusb\";\nconst configurationValue = 1;\nconst endpointNumber = 3;\n/**\n * WebUSB Transport implementation\n * @example\n * import TransportWebUSB from \"@ledgerhq/hw-transport-webusb\";\n * ...\n * TransportWebUSB.create().then(transport => ...)\n */\n\nexport default class TransportWebUSB extends Transport {\n  constructor(device, interfaceNumber) {\n    super();\n    this.device = void 0;\n    this.deviceModel = void 0;\n    this.channel = Math.floor(Math.random() * 0xffff);\n    this.packetSize = 64;\n    this.interfaceNumber = void 0;\n    this._disconnectEmitted = false;\n\n    this._emitDisconnect = e => {\n      if (this._disconnectEmitted) return;\n      this._disconnectEmitted = true;\n      this.emit(\"disconnect\", e);\n    };\n\n    this.exchange = apdu => this.exchangeAtomicImpl(async () => {\n      const {\n        channel,\n        packetSize\n      } = this;\n      log(\"apdu\", \"=> \" + apdu.toString(\"hex\"));\n      const framing = hidFraming(channel, packetSize); // Write...\n\n      const blocks = framing.makeBlocks(apdu);\n\n      for (let i = 0; i < blocks.length; i++) {\n        await this.device.transferOut(endpointNumber, blocks[i]);\n      } // Read...\n\n\n      let result;\n      let acc;\n\n      while (!(result = framing.getReducedResult(acc))) {\n        const r = await this.device.transferIn(endpointNumber, packetSize);\n        const buffer = Buffer.from(r.data.buffer);\n        acc = framing.reduceResponse(acc, buffer);\n      }\n\n      log(\"apdu\", \"<= \" + result.toString(\"hex\"));\n      return result;\n    }).catch(e => {\n      if (e && e.message && e.message.includes(\"disconnected\")) {\n        this._emitDisconnect(e);\n\n        throw new DisconnectedDeviceDuringOperation(e.message);\n      }\n\n      throw e;\n    });\n\n    this.device = device;\n    this.interfaceNumber = interfaceNumber;\n    this.deviceModel = identifyUSBProductId(device.productId);\n  }\n  /**\n   * Check if WebUSB transport is supported.\n   */\n\n  /**\n   * Similar to create() except it will always display the device permission (even if some devices are already accepted).\n   */\n\n\n  static async request() {\n    const device = await requestLedgerDevice();\n    return TransportWebUSB.open(device);\n  }\n  /**\n   * Similar to create() except it will never display the device permission (it returns a Promise<?Transport>, null if it fails to find a device).\n   */\n\n\n  static async openConnected() {\n    const devices = await getLedgerDevices();\n    if (devices.length === 0) return null;\n    return TransportWebUSB.open(devices[0]);\n  }\n  /**\n   * Create a Ledger transport with a USBDevice\n   */\n\n\n  static async open(device) {\n    await device.open();\n\n    if (device.configuration === null) {\n      await device.selectConfiguration(configurationValue);\n    }\n\n    await gracefullyResetDevice(device);\n    const iface = device.configurations[0].interfaces.find(_ref => {\n      let {\n        alternates\n      } = _ref;\n      return alternates.some(a => a.interfaceClass === 255);\n    });\n\n    if (!iface) {\n      throw new TransportInterfaceNotAvailable(\"No WebUSB interface found for your Ledger device. Please upgrade firmware or contact techsupport.\");\n    }\n\n    const interfaceNumber = iface.interfaceNumber;\n\n    try {\n      await device.claimInterface(interfaceNumber);\n    } catch (e) {\n      await device.close();\n      throw new TransportInterfaceNotAvailable(e.message);\n    }\n\n    const transport = new TransportWebUSB(device, interfaceNumber);\n\n    const onDisconnect = e => {\n      if (device === e.device) {\n        // $FlowFixMe\n        navigator.usb.removeEventListener(\"disconnect\", onDisconnect);\n\n        transport._emitDisconnect(new DisconnectedDevice());\n      }\n    }; // $FlowFixMe\n\n\n    navigator.usb.addEventListener(\"disconnect\", onDisconnect);\n    return transport;\n  }\n  /**\n   * Release the transport device\n   */\n\n\n  async close() {\n    await this.exchangeBusyPromise;\n    await this.device.releaseInterface(this.interfaceNumber);\n    await gracefullyResetDevice(this.device);\n    await this.device.close();\n  }\n  /**\n   * Exchange with the device using APDU protocol.\n   * @param apdu\n   * @returns a promise of apdu response\n   */\n\n\n  setScrambleKey() {}\n\n}\nTransportWebUSB.isSupported = isSupported;\nTransportWebUSB.list = getLedgerDevices;\n\nTransportWebUSB.listen = observer => {\n  let unsubscribed = false;\n  getFirstLedgerDevice().then(device => {\n    if (!unsubscribed) {\n      const deviceModel = identifyUSBProductId(device.productId);\n      observer.next({\n        type: \"add\",\n        descriptor: device,\n        deviceModel\n      });\n      observer.complete();\n    }\n  }, error => {\n    if (window.DOMException && error instanceof window.DOMException && error.code === 18) {\n      observer.error(new TransportWebUSBGestureRequired(error.message));\n    } else {\n      observer.error(new TransportOpenUserCancelled(error.message));\n    }\n  });\n\n  function unsubscribe() {\n    unsubscribed = true;\n  }\n\n  return {\n    unsubscribe\n  };\n};\n\nasync function gracefullyResetDevice(device) {\n  try {\n    await device.reset();\n  } catch (err) {\n    console.warn(err);\n  }\n}","map":{"version":3,"sources":["../src/TransportWebUSB.js"],"names":["configurationValue","endpointNumber","TransportWebUSB","device","deviceModel","channel","Math","packetSize","interfaceNumber","constructor","identifyUSBProductId","isSupported","list","getLedgerDevices","listen","observer","unsubscribed","getFirstLedgerDevice","type","descriptor","error","window","unsubscribe","request","requestLedgerDevice","openConnected","devices","open","gracefullyResetDevice","iface","alternates","a","e","transport","onDisconnect","navigator","close","apdu","log","framing","hidFraming","blocks","i","result","r","buffer","Buffer","acc","setScrambleKey","console"],"mappings":"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","sourcesContent":["//@flow\nimport Transport from \"@ledgerhq/hw-transport\";\nimport type {\n  Observer,\n  DescriptorEvent,\n  Subscription,\n} from \"@ledgerhq/hw-transport\";\nimport hidFraming from \"@ledgerhq/devices/lib/hid-framing\";\nimport { identifyUSBProductId } from \"@ledgerhq/devices\";\nimport type { DeviceModel } from \"@ledgerhq/devices\";\nimport { log } from \"@ledgerhq/logs\";\nimport {\n  TransportOpenUserCancelled,\n  TransportInterfaceNotAvailable,\n  TransportWebUSBGestureRequired,\n  DisconnectedDeviceDuringOperation,\n  DisconnectedDevice,\n} from \"@ledgerhq/errors\";\nimport {\n  getLedgerDevices,\n  getFirstLedgerDevice,\n  requestLedgerDevice,\n  isSupported,\n} from \"./webusb\";\n\nconst configurationValue = 1;\nconst endpointNumber = 3;\n\n/**\n * WebUSB Transport implementation\n * @example\n * import TransportWebUSB from \"@ledgerhq/hw-transport-webusb\";\n * ...\n * TransportWebUSB.create().then(transport => ...)\n */\nexport default class TransportWebUSB extends Transport<USBDevice> {\n  device: USBDevice;\n  deviceModel: ?DeviceModel;\n  channel = Math.floor(Math.random() * 0xffff);\n  packetSize = 64;\n  interfaceNumber: number;\n\n  constructor(device: USBDevice, interfaceNumber: number) {\n    super();\n    this.device = device;\n    this.interfaceNumber = interfaceNumber;\n    this.deviceModel = identifyUSBProductId(device.productId);\n  }\n\n  /**\n   * Check if WebUSB transport is supported.\n   */\n  static isSupported = isSupported;\n\n  /**\n   * List the WebUSB devices that was previously authorized by the user.\n   */\n  static list = getLedgerDevices;\n\n  /**\n   * Actively listen to WebUSB devices and emit ONE device\n   * that was either accepted before, if not it will trigger the native permission UI.\n   *\n   * Important: it must be called in the context of a UI click!\n   */\n  static listen = (\n    observer: Observer<DescriptorEvent<USBDevice>>\n  ): Subscription => {\n    let unsubscribed = false;\n    getFirstLedgerDevice().then(\n      (device) => {\n        if (!unsubscribed) {\n          const deviceModel = identifyUSBProductId(device.productId);\n          observer.next({ type: \"add\", descriptor: device, deviceModel });\n          observer.complete();\n        }\n      },\n      (error) => {\n        if (\n          window.DOMException &&\n          error instanceof window.DOMException &&\n          error.code === 18\n        ) {\n          observer.error(new TransportWebUSBGestureRequired(error.message));\n        } else {\n          observer.error(new TransportOpenUserCancelled(error.message));\n        }\n      }\n    );\n    function unsubscribe() {\n      unsubscribed = true;\n    }\n    return { unsubscribe };\n  };\n\n  /**\n   * Similar to create() except it will always display the device permission (even if some devices are already accepted).\n   */\n  static async request() {\n    const device = await requestLedgerDevice();\n    return TransportWebUSB.open(device);\n  }\n\n  /**\n   * Similar to create() except it will never display the device permission (it returns a Promise<?Transport>, null if it fails to find a device).\n   */\n  static async openConnected() {\n    const devices = await getLedgerDevices();\n    if (devices.length === 0) return null;\n    return TransportWebUSB.open(devices[0]);\n  }\n\n  /**\n   * Create a Ledger transport with a USBDevice\n   */\n  static async open(device: USBDevice) {\n    await device.open();\n    if (device.configuration === null) {\n      await device.selectConfiguration(configurationValue);\n    }\n    await gracefullyResetDevice(device);\n    const iface = device.configurations[0].interfaces.find(({ alternates }) =>\n      alternates.some((a) => a.interfaceClass === 255)\n    );\n    if (!iface) {\n      throw new TransportInterfaceNotAvailable(\n        \"No WebUSB interface found for your Ledger device. Please upgrade firmware or contact techsupport.\"\n      );\n    }\n    const interfaceNumber = iface.interfaceNumber;\n    try {\n      await device.claimInterface(interfaceNumber);\n    } catch (e) {\n      await device.close();\n      throw new TransportInterfaceNotAvailable(e.message);\n    }\n    const transport = new TransportWebUSB(device, interfaceNumber);\n    const onDisconnect = (e) => {\n      if (device === e.device) {\n        // $FlowFixMe\n        navigator.usb.removeEventListener(\"disconnect\", onDisconnect);\n        transport._emitDisconnect(new DisconnectedDevice());\n      }\n    };\n    // $FlowFixMe\n    navigator.usb.addEventListener(\"disconnect\", onDisconnect);\n    return transport;\n  }\n\n  _disconnectEmitted = false;\n  _emitDisconnect = (e: Error) => {\n    if (this._disconnectEmitted) return;\n    this._disconnectEmitted = true;\n    this.emit(\"disconnect\", e);\n  };\n\n  /**\n   * Release the transport device\n   */\n  async close(): Promise<void> {\n    await this.exchangeBusyPromise;\n    await this.device.releaseInterface(this.interfaceNumber);\n    await gracefullyResetDevice(this.device);\n    await this.device.close();\n  }\n\n  /**\n   * Exchange with the device using APDU protocol.\n   * @param apdu\n   * @returns a promise of apdu response\n   */\n  exchange = (apdu: Buffer): Promise<Buffer> =>\n    this.exchangeAtomicImpl(async () => {\n      const { channel, packetSize } = this;\n      log(\"apdu\", \"=> \" + apdu.toString(\"hex\"));\n\n      const framing = hidFraming(channel, packetSize);\n\n      // Write...\n      const blocks = framing.makeBlocks(apdu);\n      for (let i = 0; i < blocks.length; i++) {\n        await this.device.transferOut(endpointNumber, blocks[i]);\n      }\n\n      // Read...\n      let result;\n      let acc;\n      while (!(result = framing.getReducedResult(acc))) {\n        const r = await this.device.transferIn(endpointNumber, packetSize);\n        const buffer = Buffer.from(r.data.buffer);\n        acc = framing.reduceResponse(acc, buffer);\n      }\n\n      log(\"apdu\", \"<= \" + result.toString(\"hex\"));\n      return result;\n    }).catch((e) => {\n      if (e && e.message && e.message.includes(\"disconnected\")) {\n        this._emitDisconnect(e);\n        throw new DisconnectedDeviceDuringOperation(e.message);\n      }\n      throw e;\n    });\n\n  setScrambleKey() {}\n}\n\nasync function gracefullyResetDevice(device: USBDevice) {\n  try {\n    await device.reset();\n  } catch (err) {\n    console.warn(err);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}